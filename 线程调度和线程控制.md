# 线程调度和线程控制

假设计算机只有一个CPU，那么CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令，那么java是如何对线程进行调用的呢？

### 线程有两种调度模型

分时调度模型，所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片

抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些。

### java使用的是抢占式调度模型

线程的优先级设置，首先有默认优先级 是   5 

获取线程对象的优先级的方法 public final int getPriority() 返回线程的优先级。

设置线程优先级的方法 public final void setPriority(int newPriority) 更改线程的优先级

IllegalArgumentException 非法参数异常

抛出的异常表明向方法传递了一个不合法或不正确的参数。优先级不在 MIN_PRIORITY 到 MAX_PRIORITY 范围内。

线程优先级的范围：  

public static final int     MAX_PRIORITY         10 
public static final int      MIN_PRIORITY          1 

public static final int     NORM_PRIORITY       5 

线程优先级仅仅表示线程获取CPU时间片的几率。优先级高的获取CPU时间片的几率就高，但是要在次数比较多或者多次运行的时候才能看到比较好的效果.

### 线程休眠

public static void sleep(long millis) throws InterruptedException

在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。该线程不丢失任何监视器的所属权。

### 线程加入

public final void join(long millis) throws InterruptedException  等待该线程终止的时间最长为 millis 毫秒。超时为 0 意味着要一直等下去。

当前线程结束后再执行其他的线程

### 线程礼让

public static void yield()暂停当前正在执行的线程对象，并执行其他线程可以让多个线程的执行更和谐，但是不能不保证分别个来一次，他别均匀

### 守护线程

public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 方法必须在启动线程前调用。 

参数：

on - 如果为 true，则将该线程标记为守护线程。 
抛出： 
IllegalThreadStateException - 如果该线程处于活动状态。 
SecurityException - 如果当前线程无法修改该线程。

举例：坦克大战

### 中断线程

public final viod stop();让线程停止，过时了。但是还可以使用

public void interrupt() 中断线程,把线程的状态终止，并抛出一个InterruptedException

### 线程的生命周期

新建：创建线程对象

就绪：有执行咨客，没有执行权

运行：有执行资格，有执行权

​	在运行状态，由于一些操作sleep 或wait等，让线程处于了阻塞西荒台，没有执行资格，没有执行权，而另外一些操作却可以把它激活，（是sleep时间到，notify激活，）激活后线程处于就绪状态

死亡：线程对象变成垃圾，等待被回收

### 实现接口方式的好处

可以表面由于java但继承带来的局限性，

适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。

改进后的电影院售票出现的问题

问题

​	相同的票出现多次

​		CPU的一次操作必须是原子性的

​	还出现了负数的票

​		随机性和延迟导致的

注意：

线程安全问题再理想状态下，不容易出现，但是一旦出现对软件的影响是很大的

### 解决线程安全问题的基本思想

首先为甚么会出问题（这些原因也是判断一个程序是否会有线程安全问题的标准）

* 是否是多线程环境
* 是否有共享数据
* 是否有多条语句操作共享数据（即不是CPU的原子性操作）

### 解决线程安全问题实现1

同步代码块

格式：

synchronized(对象) {

需要同步的代码

}

同步可以解决安全问题的根部原因就在那个对象上，该对象如同锁的功能，多个线程同用一把锁

### 同步代码块的锁对象是任意对象

### 同步的特点

前提

​	多个线程

解决问题的时候要要注意

​	多个线程使用的是同一个锁对象

同步的好处

​	同步的出现解决了多线程的安全问题

同步的弊端

​	当线程相当多的时候。因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率

### 同步代码块的锁对象是谁？

任意对象

### 同步方法的格式以及锁对象的问题

把同步关键字加在方法上

### 同步方法的锁对象是谁？

this 

### 静态方法及锁对象问题

静态方法的锁对象是谁？   类的字节码文件对象（反射）

当前类的class文件

SelleTicket.class

因为静态方法是随着类的加载而加载。

### JDK5中Lock锁的使用

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁。在哪里释放的锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象lock

public interface Lock

Lock` 实现提供了比使用 `synchronized` 方法和语句可获得的更广泛的锁定操作。

Lock--->获取锁         void lock()

---->释放锁               void unlock()

实现该接口的子类  ReentrantLock

	//定义锁对象 多态
	private Lock lock = new ReentrantLock();



















