"D:\software\MySQL\MySQL Server 5.5\bin\mysqld" --defaults-file="D:\software\MySQL\MySQL Server 5.5\my.ini" MySQL


http://localhost/test/login.html
http://localhost/test/signup.html

 组成：英文字母，数字，$ -
 注意事项
 1.不能以数字开头
 2.不能是Java中的关键字
 3.区分大小写

 标识符
包（为了区分相同的类名所建的文件夹）
单级：name 
多级： cn.name(cn文件夹中再建一个name文件夹，其中.的作用相当于路径中的/)
规则：单词的 字母小写
类和接口
一个单词：单词的首字母大写（Student）
多个单词：每个单词的首字母大写（GoodMorning）
方法和变量
一个单词：单词的首字母小写(main)
多个单词：从第二个单词开始，每个单词的首字母大写（studentAge）
常量
一个单词：全部大写（AGE）
多个单词：每个单词都大写，中间用_隔开(STUDENT_AGE)


常量

字符串常量（“爱国福如图”）
字符常量（‘a’）
整数常量（87364）
小数常量（78.89）
布尔常量（true）
空常量  null
Java中针对整数常量提供了四种表现方式（二进制，八进制，十进制，十六进制）
进制
1byte=8bit(binary digit)
1k=1024byte
1m=1024k
1g=1024m
1t=1024g
各位进制之间的转换
8421码，快速进行各进制数的转换
任意的X进制到Y进制的转换

有符号的数据表示法（原码，反码，补码）
 原码      符号位     数值位
+7			0			0000111
-7			1			0000111
反码   正数的反码与原码相同
		负数的反码与原码符号位相同，数值位取反
		符号位    数值位
+7      0         0000111
-7      1         1111000
补码
正数的补码与原码相同
负数的补码是在反码的基础上加1
		符号位      数值位
+7       0       0000111
-7        1      1111001

变量（数学中的未知数）
   变量的组成规则
   A：变量的范围用数据类型限定，同一个变量不能从数值变成字符串
   数据类型
   B：计算机在运算时，不能拿着这个空间去运算，真正参与运算的是空间内的值，该空间的名为变量名
   变量名
   C:空间还需要有值，否则这个空间会没有意义。
   初始化值



Java语言是强类型语言，对于一种数据类型都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间
   数据类型（基本数据类型，引用数据类型）
   基本数据类型（数值型，字符型，布尔型）
   数值型（整数型【byte,short,int,long],浮点类型【float，double ])
  byte 1个字节   -128~127	short 2个字节	  int 4个字节  long  8个字节
  float  4 个字节			double 8 个字节

   字符型（char)
   布尔型(boolean)
引用数据类型（类，接口，数组
注意：
A:整数默认是int类型
B:浮点数默认是double类型
C：长整形后缀最好用L。或者l标记
D:单精度浮点数用F或f标记

+ 运算符，做加法运算
一般我们在运算时，要求参与运算的数据类型一致。
boolean 类型不能转换成其他类型
 默认转换（从小到大的转换）
 A：byte,short,chart,  在参与运算时，如果有byte，short，chart类型的东西，首先要转化为int类型的，如果参与运算的过程中有long 类型，必为Long类型，——》float——》double  以此类推

强制转换类型
格式：
目标数据类型   变量=（目标数据类型）（被转 
换的数据）
特注：
不要随意使用强制转换，因为它隐含精度问题
float f1=(float)12.345;
flaot f2=12.345F;
f1 是通过一个double 类型转换过来的，而f2 本身就是一个float 类型
class Byte{
	public static void main(String[] args){
	byte b1=3,b2=4,b;//定义三个byte类型的变量，b1 ,b2,b
	b=b1+b2;//两个byte类型的变量运算，首先转化成int型，此时b为int型的//，和byte类型冲突。
	//变量运算先进行类型提升
	//两个相加首先看类型问题，最终把结果赋值的也会考虑类型问题
	//常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。
	b=3+4;
	}
}
ascII表
‘a’97
'A'65  
'0'48
字符串数据与其他数据做+。结果是字符串类型
这里的+ 不是加法运算，而是字符串链接符


2017  9  17  day 3
数据类型中补充的几个小问题
1.在定义long 或者 float类型变量的时候，要加L或F
整数默认是int类型，浮点数默认是double 
byte short在定义的时候，他们接收的其实是一个int类型的值，这个是自己做了一个数据检测的，如果不在它们的范围内，就报错。
2. byte 值的问题
byte b1=127;
byte b2=(byte)128;//-128
byte b3=(byte)129;//-127
byte b4-(byte)130;//-126
byte范围：-128~127
128:10000000
-128:10000000(这里的1即是符号位，又是数值位)；
3.数据类型转换之默认转换
byte,short,char--int--long--float--double
long :8 字节
float： 4 字节

A：它们底层的存储结构不同。（整数都是1,0进行存储的。浮点数用科学计数法存储的）
float类型数字在计算机中用四个字节存储，遵循IEEE-754格式标准
一个浮点数有2 部分组成，底数M和指数E
底数部分：使用二进制数来表示此浮点数的实际值
指数部分：占用8bit的二进制数。可表示数值范围为0~255；

B:float表示的数据范围比long的范围要大
C:Java语言中的字符char ,如何存储一个中文汉字（Java语言中的字符占用两个字节，）
Java语言采用的是Unicode编码。
					运算符
（算术运算符，赋值运算符，比较运算符，逻辑运算符，位运算符，三目运算符）
算术运算符：

注意事项：
A:整数相除只能得到整数，如果想得到小数，必须把数据变化为浮点数类型
B:/获取的是除法操作的商，% 获取的是除法操作的余数
++ 和-- 的区别
作用：就是对变量进行自增1或者自减1
单独使用：放在操作数前面和后面的效果是一样的（而且，这种用法比较常见）
参与运算使用：
放在操作数的前面，先自增或者自减，然后再参与运算
放在操作数的后面，先参与运算，再自增或者自减
运算符的优先级（从高到低）
括号       					（）{}
正负号      				 +  -
自增自减，非				++，--，！
乘除，取余                  *  /  %  
加减                        +  -
移位运算                   <<   >>   >>>
大小关系                    <    <=   >    >=
相等关系                    ==    ！=
按位与                       &
按位异或                      ^
按位或                        |
逻辑与                        &&
逻辑或                        ||
条件运算                       ？：
赋值运算					=   +=    -=     *=    /=   %=
位赋值运算						&=    |=   >>=  <<=    >>>=


+ 的几种用法
A：加法
B:正号
C:字符串的连接符

 赋值运算符（基本的赋值运算符，扩展的赋值运算符）
 扩展运算符（+=  -=   *=   /=  %=）
+=   把左边和右边做加法，然后把值赋给左边,左边必须变量，不能是常量
-=    用左边减去右边，然后把值赋给左边
*=   把左边和右边做乘法，然后把值赋给左边
/=   用左边除以右边。然后把整数值赋给左边
%=    用左边除以右边，然后把余数赋值给左边
注意：
扩展运算符其实隐含了一个强制类型转换
s +=1;
不等价于  s=s+1;
而是等价于  s  = (s的数据类型)（s +1）;

比较运算符（== != < > <= >=  ）
  
特点：无论你的操作是简单还是复杂，结果是boolean类型,即ture ,false
注意：  ==  不能写成  = 

  逻辑运算符
    & | ^ ! && ||()
    逻辑运算符用于连接布尔类型表达式，在Java中不可以写成3<x<9，
    而是3<x & x<9.
    &  与 && 的区别(最终结果一样,但是双&&具有短路效果）
    单&时，左边无论真假，右边都进行运算
    双&&时，如果左边为真，那么右边参与运算，如果左边为假，那么右边不参与运算（短路效果）（左边是false，右边不执行）
    ||   与  |   的区别（||左边有ture 右边不执行）（|左边有ture 右边执行）
    开发中常用的逻辑运算符（&& ||  ！）


    位运算（八进制运算）（底层运用较多。可以提高运算效率）
    注意：要做位运算，首先要把数据转化为二进制（补码）
    ^  位异或的特点：一个数据对另一个数据异或两次。该数本身不变
   <<(左移)：左边最高位丢弃，右边补齐0
   >>（右移）：最高位是0，左边补齐0，最高位是1，左边补齐1
   >>>（无符号右移）：无论最高位是0还是1，左边补齐0
三目运算符（Java中唯一的一个三目运算符）
格式：（比较表达式）？表达式1：表达式2；
      比较表达式：结果是一个boolean 类型
       执行流程：
       根据比较表达式的计算返回一个 ture 或者 false
       如果条件为ture 运算后的结果是表达式1
       如果条件为false，运算后的结果是表达式2

 键盘录入（记忆）
 概述：提高程序的灵活性
 键盘录入的实现过程：
 A：导包
 		格式：
 		    import java.util.Scanner;
 		位置：
 		    在class上面

B:创建键盘录入对象
		格式：
			Scanner sc=new Scanner(System.in);

C:通过对象获取数据
		格式：
		  	int x=sc.nextInt();
流程控制语句：
顺序结构：（写在前面的先执行，后面的后执行）；
选择结构：（分支结构）【if 语句  switch 语句】
选择结构有特定的语法规则，代码要执行具体的逻辑运算进行判断，
逻辑运算的结果有两个。
所以产生选择。按照不同的选择执行不同的代码
第一种格式：
if（关系表达式）{
	语句体
}
执行流程
具体判断关系表达式看其结果是true还是false
如果是true就执行语句体
如果是false就不执行语句体

if语句的注意事项：
A:比较表达式无论简单还是复杂。结果必须是Boolean类型
B:if语句控制的语句体，如果只有一条语句，则大括号可以省略，如果是多条语句，则不能省略，建议都不要省略。
 C：一般来说，有左大括号就没有分号，有分号就没有左大括号
第二种格式：
if（关系表达式）{
	语句体1;
}else{
	语句体2;
}

执行流程：
首先判断关系表达式看其表达结果是true还是false
如果是true就执行语句体1
如果是false就执行语句体2
注意：else后面没有比较表达式，只有if后面有比较表达式

if语句的第二种格式和三目运算符的区别与联系：
三元的都可以用if语句的第二种结构成立
if语句的语句体中有输出语句时，不能用三元运算符（因为三元运算符是运算符，运算符操作完应该有一个结果，而不是一个输出）

第三种格式：(应用举例 成绩划分)
if（关系表达式1）{
	语句体1；
}else if(关系表达式2){
	语句体2；
}
。。。
else{
	语句体n+1;
}
执行流程：
首先计算表达式1看其返回值是true还是false
如果true，执行语句体1，if语句结束；
如果false，接着执行比较表达式2，看其返回值是true还是false
。。。
如果都是false，就执行语句体n+1。
if语句的三种格式：
第一种：适合做单个判断
第二种：适合做两个判断
第三种：适合做多个判断
if 语句的使用场景：
A:针对表达式是一个Boolean类型的判断
B:针对一个范围的判断
2017 9 21 day 4

switch 语句 
switch（表达式）{
	case值1:							****[[[[case 后面是冒号]]]]
	语句体1；
	break；
	case值2：
	语句体2；
	break；
	。。。
default：
语句N+1；
break；
}
switch 语句 b n    
表达式的取值（byte，short，int，char）
JDK5以后可以是枚举
JDK7以后可以是String
执行流程：
首先计算出表达式的值
其次，和case一次比较，一旦有对应的值，就会执行相应的语句，在执行过程中，遇到break就会结束
最后，如果所有的case都和表达式的值不匹配，就会执行default语句部分，然后程序结束
  注意：
  A:遇到左大括号缩进一个tab的位置
  B:关联不是很大的语句间空行
if语句和switch语句，两种选择语句的使用场景
if：
A：针对结果是Boolean类型的选择
B:针对一个范围的判断
C:针对几个常量值的判断
switch ：
A：针对几个常量值的判断

循环结构：
循环语句能在满足循环条件的情况下，反复执行某一段代码。这段被重复执行的代码被称为循环体语句，在反复执行循环体时，需要在合适的时候把循环判断条件修改为false
从而结束循环，否则会形成死循环
循环语句的组成：
初始化语句：
一条或者多条语句，这些语句完成一些初始化操作；
判断条件语句：
一个Boolean表达式，这个表达式决定是否执行循环体
循环体语句：
这个部分是循环语句，也是我们要多次做的事
控制条件语句：
这个部分在一次循环体结束后，下一次循环判断条件执行前执行，通过用于控制循环条件中的变量，
使得循环在合适的时候结束   


2017 9 24 day 4

for循环语句格式：
for（初始化语句;判断条件语句;控制条件语句）{
	循环体语句;
}

执行流程：

A执行初始化语句
B执行判断条件语句，看其结果是true还是false
   如果是false，循环结束
   如果是true，继续执行
C 执行循环体语句
D 执行控制条件语句
E 回到B执行

for循环的注意事项：（建议，规范）
判断条件语句的结果是一个Boolean类型
循环体语句如果是一条语句，大括号可以省略。如果是多条语句大括号不能省略，建议永远不要省略
一般来说，有左大括号就没有分号，有分号就没有左大括号

while 循环语句的基本格式
基本格式
while（判断条件语句）{
	循环体语句；
}
扩展格式：
初始化语句；
while（判断条件语句）{
	循环体语句；
	控制条件语句；
}
while循环和for循环可以等价转换
while 循环 与for 循环 的区别（变量的定义位置）
使用区别：
如果想在循环结束后，继续使用控制条件的那个变量。用while循环
否则使用for循环
如果不确定，建议使用for循环
原因：for循环定义的变量只在循环结构中有效，循环结束后，变量就会从内存中消失，可以提高内存的使用效率
另外，
如果是一个范围的。用for循环非常明确
如果范围不是很明确就用while循环

do - whilie
基本格式
do{
	循环语句体
}while（判断条件语句）；
扩展格式
初始化语句；
do{
	循环体语句；
	控制条件语句；
}while（判断条件语句）

三种循环结构的区别
do-while 循环至少执行一次循环体
for while 循环必须先判断条件是否成立，然后决定是否执行循环语句。
我们一般使用哪种循环？
首先考虑for 然后是while 再然后是do  while
特别注意    死循环的注意事项
A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。
B:两种最简单的死循环格式
while（true）{
	
}
for（； ；）{
	
}
注意：for循环（）内的三个条件，并不一定全部都有 
System.out.print();该语句的作用是输出不换行
System.out.println();该语句的作用是空行

			//注意："\x",x表示任意，转移字符
		//‘\t’  tab 键的位置
		//‘\r’ 回车
		//'\n'   换行

跳转控制语句
Java中的GOTO是保留字，目前还不能用，虽然没有GOTO语句可以增强程序的安全性，但是也带来很多不便，比如，想在某个循环知道某一步的时候就结束，现在就做不了这件事，为了弥补这个缺陷。Java提供了break 和continue，return来实现控制结构的跳转和中断。
break 中断
continue 继续
return 返回 
break 使用场景
A: switch 语句中
B:循环语句中（循环语句中加入了if判断语句）
注意：离开上面两个场景，无意义
如何使用：
A：跳出单层循环
B:跳出多层循环 
  想要实现这个效果，就必须知道一个东西，带标签的语句
  格式：
      标签名：语句

continue 使用场景
在循环语句中，离开这个场景的存在就没有意义
 continue的作用
 单层循环对比break。然后总结两个区别
 A break 退出当前循环
 B continue 退出本次循环
 也可以在带标签的使用
 
2017 9 28  day  5
方法:完成某个功能的代码块
：在很多语言里都有函数的定义
函数在Java中就是方法
格式：
修饰符 返回值类型  方法名（参数类型 参数名1，参数类型 参数名2...）{
	函数体；
	return 返回值
}

方法的注意事项：
方法不调用不执行
方法与方法是平级关系，不能互相嵌套
方法定义的时候，参数之间用逗号隔开
方法调用的时候，不需要再传递数据类型


方法调用的三种方式：
单独多用（void类型）
输出调用
赋值调用

返回值比较明确时，三种调用方式都可以


方法重载（在同一个类中，方法名相同，参数列表不同，与返回值类型无关）
在同一个类中，允许存在一个以上的同名方法，只要他们的参数个数或者参数类型不同即可
方法重载特点
与返回值类型无关，只看方法名和参数列表
在调用时，虚拟机通过参数列表的不同来区分同名方法

数组
数组是存储多个变量（元素）的东西（容器）
这多个变量的数据类型要一致
数组
（存储同一个数据类型多个元素的集合，也可以看做是容器）
（数组既可以存储基本数据类型，也可以存储引用数据类型）
数组的定义格式
格式1：数据类型[]数组名；  int[] a;定义一个int类型的数组a变量
格式2：数据类型 数组名[];  int a[];定义一个int类型的a数组变量
注意：两种格式，效果是一样的，只是念法有些不同，推荐使用第一种

数组的初始化
java中的数组必须先初始化，然后才能使用
所谓初始化，就是为数组中的数组元素分配内存空间，并为每个数组元素赋值
数组的初始化方式
动态初始化，初始化时只指定数组长度，由系统为数组分配初始值
静态初始化，初始化时指定每个数组元素的初始值，由系统决定数组长度
动态初始化 格式：

数据类型[] 数组名=new 数据类型[数组长度]

数组长度其实就是数组中元素的个数
例如：
int[] arr=new int[3];
左边<>
int：说明数组中的元素的数据类型是int类型
[]：说明这是一个数组
arr :是数组名
右边<>
new：作用是为数组分配内存空间
[]:数组
3：数组长度，其实也是数组中元素的个数

<解释>：定义一个int类型的数组。这个数组可以存放三个int类型的值。
如何获取数组中的元素？
通过：
     数组名[索引]；
     最大的索引值即是    数组长度-1

 java中的没内存分配，为了提高程序效率，就对数据进行了不同空间的分配，具体划分为一下五个内存空间：

 栈 存储局部变量
 堆 存储new出来的东西
 方法区（后续待讲）<面向对象部分详细讲解>
 本地方法区（和系统相关）<了解>
 寄存器（给CPU用）<了解>

局部变量：在方法定义中或者方法声明上的变量都称为局部变量

int[] arr=new int[4];           			
System.out.println(arr);//地址值————>十六进制表示的地址
System.out.println(arr[0]);//0
System.out.println(arr[1]);//0
System.out.println(arr[2]);//0



堆内存的特点：
A：每一个new出来的东西都有地址值
B：每个变量都有默认值
		byte short int long  0
		float double   0.0
		chart ‘\u0000’
		Boolean   false
		引用类型    null
C：使用完毕就变成了垃圾，但是并没有立即回收，会在垃圾回收器空闲的时候回收


栈   内存的数据用完就释放
   静态初始化
静态初始化，初始化时指定每个数组元素的初始值，由系统决定数组长度
格式：
	数据类型[] 数组名=new 数据类型[]{元素1，元素2，。。。}
举例：
	int[] a=new int[]{1,3,5};
<解释>：
	定义了一个int类型的数组，这个数组中了一存放3个int类型的值，并且其初始值分别为1.3.5
<简化写法>：
		int[] a={1,3,5}
注意事项：
		不要同时动态和静态进行
		如以下格式：
		int[] a=new int[3]{1,3,5}     <错误>

数组操作的两个常见小问题
A：数组索引越界异常，原因：访问了不存在的索引
B: 引用类型的常量，空常量null时，空指针异常。原因：地址为空，数组已经不再指向堆内存了，而你还要用数组名去访问元素。

	int[] a={1,2,3};
	a=null;
	System.out.println(a[0]);

数组的练习（常见操作）
（1）数组遍历（依次输出数组中的每个元素）
（2）数组获取最值（获取数组中的最值）
（3）数组元素逆序（就是把元素对调）
（4）数组查表法（根据键盘录入索引，查找对应星期）
（5）数组元素查找（查找指定元素第一次在数组中出现的索引）
（6）数组排序和二分查找（后面在数组高级部分讲解）
  数组遍历：
  用for循环
  数组给我们提供了一个属性：length 专门用于获取数组的长度
格式：
		数组名.length          返回数组长度

遍历数组的方法
返回值   void
参数列表  数据类型[] 数组名     如：int[] arr

2017 10 03    day 6
二维数组（就是一个元素为一维数组的数组）
二维数组的定义格式：
格式1：
	数据类型[][] 变量名=new 数据类型[m][n];
    其中：
    m表示这个二维数组有多少个一维数组
    n表示每一个一维数组的元素个数
举例：
    int[][] arr=new int[3][2];
    定义一个二维数组arr
    这个数组有3个一维数组，名称是arr[0],arr[1],arr[2]
    每个一维数组有两个元素，可以通过arr[m][n]来获取
        表示获取第m+1个数组的第n+1个元素
格式2：
	数据类型[][] 变量名=new 数据类型[m][];
	其中：
	m 表示一个数组有多少个一维数组
	这一次没有直接给出一维数组的元素个数，可以动态的给出
举例：
	int[][] arr=new int[3][];
	arr[0]=new int[2];
	arr[1]=new int[3];
	arr[2]=new int[1];
格式3：
	数据类型[][] 变量名=new 数据类型[][]{{ 元素。。。}，{元素。。。}，{元素。。。}}

    简化格式：
    数据类型[][] 变量名={{元素。。。}，{元素。。。}，{元素。。。}}
    举例：
    int[][] arr={{2,3,4},{4,6},{8}};





  java中的参数传递问题：
  基本类型：形式参数的改变对实际参数没有影响
  引用类型：形式参数的改变直接影响实际参数，因为传递的是地址值
 



 									面向对象
面向对象思想
类与对象及其使用
对象的内存图
成员变量和局部变量
匿名对象
封装（private）
this 关键字
构造方法
static  关键字

面向对象的思想
数组，当有多个数组需要遍历时，我们可以将遍历的代码封装到方法中，需要遍历时，就调用相应的方法即可，提高代码的复用性，在对数组进行遍历的基础上继续增加需求，比如获取最值，数组逆序等，同样需要将这些功能封装到相应的方法中。这样继续封装会发现方法越来越多，于是就想能不能将这些方法继续进行封装？通过前面的讲解我们知道  类  是可以封装方法的，所以我们考虑使用类来封装多个方法，将来再做数组的操作时不用去找具体的方法，先找到这个  类，然后找到类中的方法。这就是面向对象的编程思想。 

  面向过程
 之前，我们完成需求的步骤：
    首先，搞清楚我们要做什么，然后分析怎么做，最后再用代码体现，一步一步的实现，而具体的每一步都需要我们去实现和操作。这些步骤互相调用和协作，完成我们的需求。
 在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。
 什么是面向过程开发？ 


        面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。
 面向过程的代表语言：C语言
   面向对象思想
   面向对象是基于面向过程的编程思想

   面向过程：强调的是每一个功能的步骤
   面向对象：强调的是对象，然后由对象去调用功能

 面向对象的思想特点：
     A：是一种更符合我们思想习惯的思想
     B:可以将复杂的事情简单化
     C：将我们从执行者变成指挥者
举例：
    买电脑：
        面向过程：我得了解电脑——了解我自己的需求——找对应的参数信息——去中关村买电脑——讨价还价——                          买回电脑
        面向对象：我知道我要买电脑--班长去给我买--班长就买回来了
    洗衣服：
    	面向过程：把衣服脱下--找一个盆--放点洗衣粉--加点水--把衣服扔进去--搓一搓--清洗衣服--拧                     干--晾起来
    	面向对象：把衣服脱下来--打开全自动洗衣机--扔进去--一键即可--晾衣服
    吃饭：
    	面向过程：去超市买菜--摘菜--洗菜--切菜--炒菜--盛起来--吃
    	面向对象：去饭店吃法，你--服务员（点菜）--厨师（做菜）--服务员（端菜）--吃



开发  设计  特征 
面向对象开发
	就是不断的创建对象，使用对象，指挥对象做事
面向对象设计
	就是在管理和维护对象之间的关系
面向对象特征
	封装（encapsulation）
	继承（inheritance ）
	多态（polymorphism）

类与对象的关系
编程语言，就是为了模拟现实世界的事物，实现信息化，比如去超市买东西的计费系统，去银行办业务的业务系统
如何表示一个现实世界事物？
属性   是该事物的描述信息
行为   是该事物能够做什么

举例：
    学生事物

java语言最基本单位是类，所以，我们就应该把事物用一个类来体现
 
 事物               类
 	属性				成员变量
 	行为				成员方法
 类：是一组相关的属性和行为的集合，是一个抽象的概念
 对象：是该类事物的具体表现形式，具体存在的个体


								案例
事物：
	属性   事物的信息描述
	行为   事物的功能
类： 
	成员变量     事物的属性
	成员方法     事物的行为

定义一个类，就是定义该类的成员变量和成员方法、

					一个学生类

学生事物：
		属性：姓名，年龄，地址
		行为：学习，吃饭，睡觉
把事物转化为对应的类：
 学生类：
 		成员变量：姓名，年龄，地址
 		成员方法：学习，吃饭，睡觉
 成员变量：
 		和以前变量的定义是一样的格式，但是位置不同，在类中方法外
 成员方法：
 		和以前的方法定义是一样的格式，但是今天把static 先去掉

 					步骤
 首先定义一个类
 class Student{
 //定义变量
 //姓名
 String name;
 //年龄
 int  age;
 //地址
 String address;

 //定义方法
 //学习的方法
 public void study(){
 	System.out.println("学生爱学习！");

 }

 //吃饭的方法
 public void eat(){
 System.out.println("学习饿了，要吃哒");
 }

 //睡觉的方法
 public void sleep(){
 System.out.println("学习累了。要睡觉");

 }
  }


  在一个java文件中写两个类，一个基本类，一个测试类
  注意：文件名称和测试类名称一致

  如何使用？
  		创建对象使用
  如何创建对象？
  		格式：类名  对象名=new 类名（）;

  如何使用成员变量？
  		格式：对象名.变量名
  如何使用成员方法？
  		格式：对象名.方法名（.....）//

  private
  this 关键字 


   构造方法construction   construct    首先是一个方法
   作用：给对象的数据进行初始化
   格式：
   		A:方法名与类名相同
   		B:没有返回值类型，连void都没有
   		C:没有具体的返回值

反编译工具：Xjad

	构造方法的重载（方法名相同，形参不同，包括（参数类型，参数个数））
	注意，方法带多个形参时，参数类型可以不同，中间要用逗号隔开。

给成员变量赋值有两种方法：
			A: getXxx
			B：构造方法

类的组成：
		成员变量
		构造方法
		成员方法
 成员方法具体划分：
 		根据返回值
 			有明确返回值方法
 			返回void类型的方法
 		根据形式参数
 			无参数方法
 			带参数方法
一个基本类的标准代码写法
	类
		成员方法
		构造方法
			带参数构造方法
			不带参数构造方法
		成员方法
		 	getXxx()
		 	setXxx()
		给成员变量赋值的方法
			无参数构造方法+setXxx()
			带参数构造方法
成员方法：
 

			show()   输出该类的所有成员变量值

  类的初始化过程	


    class Student{
    private String name="linqingxia";
    private int age =27;
    public Student(){
    name="liuyi ";
    age=20;
    }
    }
    class StudentDemo{
    public static void main(String[] args){
    Student s=new Student();
    }
    }



    Student s=new Student();做了哪些事情
    A:把Student，class 文件加载到内存
    B:在栈内存给s 变量开辟一个空间
    C：在堆内存为学生对象申请一个空间
    D：给成员变量进行默认初始化  null 0 
    E：给成员变量进行显示初始化。“linqingxia”,27;
    F：通过构造方法对成员变量进行初始化
    		"liuyi "   20
    G：数据初始化完毕，然后把堆内存的地址值给栈内存的s 变量

    变量什么时候定义为成员变量？
    		如果这个变量是用来描述这个类的信息的，那么该变量就应该定义为成员变量
    变量到底定义在哪里好？
    		变量的范围越小越好。因为能及时被回收

improt java.util.Scanner   必须放在class前面，当一个java文件中有多个class时，要放在第一个class的前面


       static   关键字的引入
       定义一个类
姓名和年龄都是变化的，这个我可以接受，因为每个人的姓名和年龄是不同的，
但是，我们选取的几个人都是中国人，他们的国籍都是一样的，
一样的国籍，每次创建对象，在堆内都要开辟这样的空间，实属浪费
				措施：
				针对多个对象有共同的这样的成员变量值的时候，java提供了static 关键字

       ststic 的特点（可以修饰成员变量，成员方法）
			A：随着类的加载而加载（main方法为例，类加载的时候。main方法跟着加载）
			B:优先于对象存在（对象只有创建的时候才存在）
			C:被类的所有对象共享
					举例：同一个的班级的学生共同使用同一个班级编号
		由以上特点可以得知，什么时候使用静态？
				如果某个成员变量或者方法。是被所有对象共享的，那么它就应该定义为静态
						举例：
								饮水机（适合用静态修饰）
								水杯（不能用静态修饰）
			D:可以通过类名调用
					其实，他本身也可以通过对象调用		
							推荐使用类名调用
							静态修饰的内容，我们称其为与类相关的。也叫类成员
							而非静态的是对象成员
										

内存图：
Static  注意事项：
		static  关键字的注意事项
		A: 在静态方法中是没有this 关键字的
			如何理解呢？
			因为静态是随着类的加载而加载。this是随着对象的创建而存在。
			静态比对象先存在，先存在的的东西并不能去访问后存在的东西。
		B:静态方法只能访问静态的成员变量或者静态的成员方法
			静态方法：
					成员变量：只能访问静态变量、
					成员方法:只能调用静态的方法
			非静态方法：
					成员变量：可以是静态的，也可以不是静态的
					成员方法：可以调用静态的方法，也可以调用非静态的方法、

静态变量与成员变量的区别
	所属不同：
		静态变量属于类，所以也称为类变量
		成员变量属于对象，所以有称为实例变量（对象变量）
	内存中位置不同
		静态变量存储于方法区的静态区
		成员变量存储于堆内存
	内存出现的时间不同
		静态变量随着类的加载而加载，随着类的消失而消失
		成员变量随着对象的创建而存在，随着对象的消失而消失
	调用不同
		静态变量可以通过类名调用，有可以通过对象调用
		成员变量只能通过对象调用
		
		main 方法是静态的
		public static void mian(String[] args)
		public 公共的，访问权限是最大的，由于main方法是被JVM调用，所以访问权限要足够大，
		static 静态的，不需要创建对象，通过了类名就可以，方便被JVM调用
		void 因为我们曾经说过，方法的返回值是返回给调用者的，
				而main方法是被JVM调用，不需要给JVM 返回值
		main 是一个常见的方法入口，一个通用的名称，虽然不是关键字，但是被JVM识别
					几乎所有语言都是以main作为入口
		String[] args 这是一个字符串数组，值呢？
						以前用于接受键盘录入的
						格式是：
								java MainDemo hello world java 



		//如果在ArrayTool类中，将构造方法私有（private）修饰。
		那么在测试类中就不能再创建对象了
		// 通过对象调用非静态的方法
		//ArrayTool at=new ArrayTool();
		//at.printArry(arr);

		//通过类名直接调用静态的方法
		ArrayTool.printArry(arr);


		//把构造方法私有，外界就不能再创建对象了
	         Private ArrayTool(){};


		//public void printArry(int[] arr){
	//方法改进为静态后，就可以直接通过类名调用
		public static void printArry(int[] arr){

API  (application  programming interface)
应用程序编程接口（帮助文档）



	制作工具类的说明书：
		A:写一个工具类
			ArrayTool
		B:对这个类加入文档注释
				怎么加，加什么
		C:用工具解析文档注释
				javadoc 工具
			格式：
				javadoc -d 目录 -author -version ArrayTool.java

				其中：	目录可以写一个文件夹的路径

				编译错误1：找不到可以文档化的公共或受保护的类
				分析，那是因为类的权限不够，用public 修饰类

		帮助文档的使用
	打开帮助文档		  显示   索引  输入搜索内容

		注意：  
			看包   java.lang 的包下的类不需要导包，其他包下的类都需要导包
			例如：   java.util.Scanner
然后再看类的解释和说明
	以及 	
		例子   
	还有  
		该类的版本
	最后
		类的结构  
				成员变量     字段摘要
				构造方法     构造方法摘要
				成员方法     方法摘要
	学习构造方法
		A：有构造方法就创建对象
		B：没有构造方法    成员可能都是静态的
	看成员方法
	A：左边 
		是否静态，如果静态，可以通过类名调用
		返回值类型，人家返回什么就用什么接受
	




		看方法名，方法名称不要写错
		参数列表，人家要什么就给什么，人家要介个就给几个
	

	代码块（codeDemo）
	在java中。使用{} 括起来的代码称为代码块
	根据其位置和声明的不同，可以分为局部代码块。构造代码块。静态代码块，同步代码块（多线程讲
	局部代码块


		代码块
	局部代码块:局部位置，方法的定义中，用于限定变量的生命周期
	构造代码块：在类中的成员变量的位置,用{} 括起来，每次调用构造方法执行前，都会先执行构造代码块
				作用：可以把多个构造方法中的共同代码放在一起，对对象进行初始化

	静态代码块：在类中的成员位置，用{}括起来的代码，只不过它用static 修饰了，所以它在类被加载的时候就已经开始执行了
				特点：静态代码块，在程序中只执行一次
				作用：一般是对 类 进行初始化

			面试题：
					静态代码块：构造代码块，构造方法的执行顺序
					
							静态代码块   先于  构造代码块  先于  构造方法

					静态代码块  只执行一次
					构造代码块    每次调用构造方法都执行




		继承
		格式：
		class Fu{}
		class Zi extends Fu {} 
		其中  Fu  和Zi 是定义的类名
继承概述：[多个类中存在相同属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需再定义              这些属性和行为，只要继承那个类即可]
		  把多个类中相同的内容给提取出来定义到一个类中

如何实现继承
	java提供了一个关键字   extends

格式
		class 子类名   extends  父类名{}
	单独的这个类称为父类。基类，或者超类；这多个类称为  子类   或者    派生类

好处

	提高了代码的复用率
	提高了代码的维护性
	让类与类之间产生了关系，是多态的前提

注意：类与类之间产生了关系。其实也是继承的一个弊端
		原因是类的耦合增强了

		开发的原则：低耦合，高内聚
		耦合：类与类的关系
		内聚：就是自己完成某件事的能力

		java中只支持单继承，不支持多继承
			一个类中只能有一个父类，不可以有多个父亲
			class SubDemo extends Demo{}   //ok
			class SubDemo extends Demo1,Demo2,..//error
		java 支持多层继承（继承体系）
			class A{}
			class B extends A{}
			class C extends B{}
	继承的注意事项：
		A 子类只能继承父类非私有的成员（成员变量，成员方法）
			其实这也是继承的一个弊端，因为这样打破了封装性
		B:子类不能继承父类的构造方法，但是可以通过super 关键字去访问父类的构造方法
		C：不要为了部分功能区继承


		我们到底什么时候用继承呢？
			继承中类之间体现的是：[is a ] 的关系
				Person
					Student
					Teacher
				水果、
					苹果
					香蕉
					橘子
				采用假设法：
					如果有两个类 A B ，只有他们符合 A是B 的一种，或者 B 是  A的 一种，就可以使用继承





			

	类的组成：
	成员变量
	成员方法
	构造方法 
	现在我们讲了继承，所以我们就应该考虑一下，类的组成部分的各自关系

	继承中成员变量的关系
	测试：	子类中的成员变量和父类中的成员变量名称不一样，这个很简单

			子类中的成员变量和父类中的成员变量名称一样，

		在子类方法中访问一个变量的查找顺序
			在子类方法的局部范围查找。有就使用
			在子类的成员范围查找，有就使用
			在父类的成员范围找。有就使用    
		如果找不到就报错

			注意：  不能在父类的局部范围内找，因为方法只用被调用时才执行，而且方法之间是平级关
						系，一个方法无法访问到另一个方法的局部变量
				
	this 关键字   和  super 关键字的 区别
		super的用法和this很像
		A： this 代表本类对应的引用
		B： super 代表父类 存储空间的标识（可以理解为父类的引用，可以操作父类的成员）
	用法（this和super均可以如下使用）
		A： 访问成员变量
			this.成员变量        super.成员变量
		B：访问构造方法（子父类的构造方法时候将）
			this（。。）  				super（。。）
		C：访问成员方法（子父类的成员方法问题时候讲）
			this.成员方法（）           super.成员方法（）

			继承中构造方法的关系：
				子类中所有的构造方法默认都会访问父类中 空 参数的构造方法
			原因：
				因为子类会继承父类中的数据。可能还会使用父类的数据，所以，子类初始化之前，一定要先完成父类数据的初始化
				每一个构造方法的第一条语句默认都是：super()

		
		如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？
		
		正常情况下，为了避免上述情况的发生，我们会自己写上无参的构造方法
			解决办法：
			A： 在父类中加一个无参构造方法
			B：子类通过 super 去显示调用父类其他的带参的构造方法
			C：子类通过 this 去调用本类的其他构造方法

		子类中一定要有一个去访问了父类的构造方法。否则父类数据就没有初始化

		注意事项：
			this 和 super 调用构造的时候，一定要出现在第一条语句上
				[因为：this 或者super 如果在其他位置。构造方法中，默认第一句是super 或 this语句，对父类进行初始化，
					  然后执行到super 或者 this 语句的时候，又要对父类进行初始化，就会出现多次初始化的情况。]
					因为： 
						如果不是放在第一条语句中，就可能对父类进行多次初始化

		继承中的成员方法的关系：
	A:子类中的方法和父类中的方法声明不一样
	B 子类中的方法和父类中的方法声明一样
		通过子类调用方法
			A 先看子类中有没有这个方法，有就使用
			B 再看父类中有没有这个方法，（父类的父类暂时不考虑）。有就使用，没有就报错



						

方法重写和方法重载
	方法重写：<也叫方法覆盖，方法复写>
		在子类中，出现和父类中一模一样的方法声明的现象[包括：方法名，参数列表，返回值类型都一样]
			使用特点：<ExtendsDemo8>
				如果方法名不同，就调用对应的方法
				如果方法名相同，最终使用的是子类自己的
	方法重写的应用：
		当子类需要父类的功能，而功能主体子类有自己特有的功能时，可以重写父类中的方法，这样就即沿袭了父类的功能，又定义了子类特有的内容
	方法重载：
		同一个类中，出现的方法名相同，参数列表不同的现象

	方法重载能改变返回值类型，因为它和返回值类型无关

	方法重写的注意事项：
	A 父类中 私有方法不能被重写
	B 子类重写父类方法时，访问权限不能更低,最好一致
	C 父类静态方法，子类也必须通过静态方法重写
		（其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中会讲）
	结论：子类和父类的方法修饰符，最好能一样

	override：方法重写 
	overload：方法重载  
	
this    代表当前类的对象引用
super    代表父类存储空间的标识，（可以理解为父类的引用，通过这个东西可以访问父类的成员）

场景：
	成员变量
		this  成员变量
		super 成员变量
	构造方法
		this（。。。）
		super（。。。）

		class Dog extends Animal{
	public Dog(){}
	public Dog(String name,String color,int age){
		//获取 动物类的 参数值
		super(name,color,age);
	}
	成员方法
		this ：成员方法
		super：成员方法 

        day    9

继承中代码的体现

由于继承中方法有一个现象：方法重写

所以，父类的功能，就会被子类给覆盖
有些时候我们不想让子类覆盖掉父类的功能，只能让他使用
这个时候，针对这种情况，java就提供了一个关键字  ：  final 
		final  常见的是可以修饰  变量  方法  类 

fianl  可以修饰类 ： 方法  变量
特点：
	final 修饰 类的特点  该类不能被继承，一般为最底层的类
	final 修饰 方法的特点  该方法不能被重写
	final 修饰 变量的特点  该 变量不能被重新赋值，因为这个变量其实是常量
		
常量：
	A：字面值常量
		'hello' 10,true
	B :自定义常量
	final int =10；

	fianl 关键字 
权限修饰符修饰局部变量并没有什么实际意义，因为局部变量在方法内是被封装好的

但是，final 关键字可以修饰局部变量
面试题：
	final修饰局部变量的问题
		final 可以修饰局部变量

		A:基本数据类型的变量   基本类型的值不能发生改变

		B:引用数据类型的变量   引用类型的地址值不能发生改变，但是。该对象的堆内存的值是可以改变的


	final  修饰变量的初始化时机
A :被final 修饰的变量只能赋值一次
B：在构造方法完毕前，（非静态的变量）



多态的前提 (polymorphic)
	有继承关系
	有方法重写(其实没有也是可以的，但是没有这个就没有意义)

	动物 d=new 猫()
	d.show()
	动物 d=new 狗()
	d.show()

	有父类引用指向子类对象
		父 f=new  子()
		动态中的成员访问特点

		A：成员变量
			编译看左边。运行看左边

		B: 构造方法 
			创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
		C：成员方法
			编译看左边  ，运行看右边
		D：静态方法
			编译看左边，运行看左边
			（静态是和类相关的，算不上重写，所以，访问的还是左边的）

	多态的前提和体现
		有继承关系
		有方法重写
		有父类引用指向子类对象
 
		多态的好处：
	1.提高了代码的维护性（继承）
	2.提高了代码的扩展性（ 由多态保障   ）


	多态的弊端：
	不能使用子类的特有功能


	在java中，一个方法体的方法，定义为抽象方法，而类中如果有抽象方法，该类必须是抽象类
	抽象类的概述（动物不应该定义为具体的东西，而且动物中的吃，睡等行为也不应该是具体的）
	我们把一个不是具体的功能称为抽象功能，而一个类中如果有抽象的功能，这个类必须是抽象类
	 抽象类的特点：
	A： 抽象类和抽象方法必须用abstract关键字修饰
	 格式
	 abstract class 类名 {}
	 public abstract void eat();

	B： 抽象类不一定有抽象方法，有抽象方法的 类 一定是抽象类

	C ： 抽象类不能实例化   因为它不是具体的
			 Animal a=new Animal();// 错误: Animal是抽象的; 无法实例化

 	抽象类是有构造方法的，但是不能实例化，构造方法的作用：
 		用于子类访问父类数据的初始化

 		抽象类的子类
 		A:如果不重写先抽象方法，该子类是一个抽象类
 		B：重写所有的抽象方法，这个时候子类是一个具体的类

 		抽象类的实例化问题[其实是靠具体的子类实现的，是多态的方式]
 		如果 Animal.class 是抽象类的父类，Pig.class是重写了所有方法抽象方法的子类
 		则：
 		Animal a=new Pig();
 		可以通过上述方式对 抽象类进行实例化	


 		抽象类的成员特点
成员变量

	成员变量即可以是变量也可以是常量
构造方法
	有  作用是用于子类访问父类的初始化

成员方法
即可以是抽象的，也可以是非抽象的

抽象类的成员方法特性：
A:抽象方法  强制要求子类做的事情
B：非抽象方法  子类继承的事情，提高代码的复用性


注意，当子类中有自己特有的东西时，一般用自己的类进行测试（不用多态）

一个类中如果没有抽象方法，可不可以定义为抽象类？意义？
可以
意义是：不让创建对象

抽象关键字不能和哪些关键字共存
private    冲突
final      冲突
static     无意义


//错误: 非法的修饰符组合: abstract和private
	//private abstract void show();
	//因为私有 不能被继承，即不能被重写，而抽象类则强制抽象方法被重写

	//final abstract void show();
	因为最终的是不能被重写的，而抽象类强制要求方法被重写

	static abstract void show();

	static 修饰方法不需要创建对象 可以被类直接调用  假如抽象类是FU.class 则Fu.show()、但是。show方法没有方法体，所以调用无意义


	接口
		[在猫狗案例中，我们的狗一般是看门，猫一般是作为宠物，但是还存在一些情况：经过驯养员等训练出来的：猫钻火圈，狗跳高，狗计算等，这些行为并不是所有的猫或者狗所具有的，所以这些功能定义在动物类不合适，同时也不适合定义在猫 或者 狗的类中，因为这只是部分猫或者狗所具有的行为。]
		所以：
			为了体现事物功能的扩展性，java中提供了接口来定义这些额外的功能，并不给出具体的实现，将来哪些猫或者狗需要被训练，只需要这些猫狗将其实现就可以了。


			   接口的特点：

接口的特点：
	A:接口关键字 interface 表示
	格式：interface 接口名{}
	B 类实现接口用 implements表示
	class 类名 implements 接口名{}
	C :接口是抽象的，不能实例化
	那么接口如何实例化呢？
	按照多态的方式来实例化
	D：接口的子类
	A :可以是抽象类，但是意义大，因为抽象类还需要子类
	B ：可以是具体类，但是 要将接口中的所有抽象方法重写



	由此可见
	A：具体类多态（几乎没有）
	B：抽象类多态（常用）
	C：接口多态（最常用）


接口成员特点
成员变量

[只能是常量  并且是静态的]
接口中的变量默认是常量，不能再进行赋值
默认修饰符：public static final
建议：自己手动给

构造方法
接口没有构造方法
成员方法
成员方法默认是public  abstract 类型的
只能是抽象方法
默认修饰符：public abstract 
建议  自己手动给出




所有的类都默认继承自一个类 object 
类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。
构造方法摘要 
Object() 
 
因为Object类只提供了无参构造，所以所有子类默认调用的都是父类的无参构造方法



类与类
	继承关系，只能单继承，可以多层继承
类与接口
	实现关系,可以单实现，也可以多实现，并且可以在继承一个类的同事，实现多个接口
接口与接口
	继承关系,可以单继承也可以多继承

	抽象类与接口的区别
抽象类：
	成员区别：可以是变量或者常量

	构造方法：有无参和带参
	成员方法：可以抽象，可以非抽象
接口：
	成员区别：只能是常量

	构造方法：没有
	成员方法：只可以是抽象
关系区别
	类与类
		继承关系，只能单继承，可以多层继承
	类与接口
		实现关系,可以单实现，也可以多实现，并且可以在继承一个类的同事，实现多个接口
	接口与接口
		继承关系,可以单继承也可以多继承
设计理念不同
	抽象类  被继承体现的是 “is a” 抽象类中定义的是该继承体现的共性功能
	接口 被实现体现的是 “like a ” 接口中定义的是该继承体系的扩展功能


	乒乓球运动员  篮球远动员
乒乓球教练   篮球教练
跟乒乓球相关的人都需要学习英语

分析：
乒乓球运动员（具体类）  篮球运动员（具体类）    乒乓球教练 （具体类）   篮球教练（具体类）
			
			运动员	（抽象类）								教练（抽象类）
				[学习（）]										[教（）；]
								

										接口（学习英语）
										[口语]

								人（抽象类）
				[姓名  年龄  吃饭（）；睡觉（）{}]


形参和返回值的问题
形式参数
	基本数据类型
	引用类型
返回值类型
	基本数据类型
	引用类型

引用类型：
类   			需要的是该类的对象
抽象类          因为抽象类本身不能实例化  所以它需要的其实是子类（具体类）通过多态实现
接口   			一个方法如果需要接口名称，实现上是需要的该接口的实现类对象


匿名对象
new StudentDemo().method(new Student())

StudentDemo sd=new StudentDemo();

Student s=new Student()
sd.method(s);

返回值类型
	基本数据类型
	引用类型
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ：
	类:    如果一个方法的返回值类型是一个类名。实际上是返回的该类的对象
	抽象类   实际上返回的是该抽象类子类的对象
	接口   实际上返回的是 该接口的实现类的 对象 

	连编程：
	每次调用方法完毕，返回的是一个对象，这样	包其实就是文件夹
才能继续电影方法

	包的概述
	作用：
	A: 对类进行分类管理
	B：把相同的类名放到不同的包中
	举例：
			学生：增删改查
			老师：增删改查
			方案一：
			按照功能分：
				cn.itcast.add
					AddStudent
					AddTeacher
				cn.itcast.delete
					deleteStudent
					deleteTeacher
				cn.itcast.update
					updateStudent
					updateTeacher
				cn.itcast.find
					findStudent
					findTeacher
			按照模块分
				cn.itcast.teacher
					AddTeacher
					deleteTeacher
					updateTeacher
					findTeacher
				cn.itcast.student
					AddStudent
					deleteStudent
					updateStudent
					findStudent

				包的定义
				package 包名;
				多级包用.分开
				注意事项
				A:package 语句必须是程序的第一条可执行的代码（类的上面）
				B:package 语句在一个java文件中只能有一个
				C:如果没有package ，默认表示无包名


				带包的编译和运行
				A: 手动式 	
					a 编写一个带包的java文件
					b 通过javac 命令编译该文件夹
					c 手动创建包名
					d 把b 步骤的class 文件方法在c步骤的最底层包
					e 回到和包根目录在同一目录的地方，然后运行
						带包运行  java cn.itcast.hello
				B :自动式
					a  编写一个带包的java文件
					b javac 编译时带上-d 即可
						javac -encoding utf8 -d . Hello.java
					c 回到和包根目录在同一目录的地方，然后运行
						带包运行


不同包下类之间的访问：


第一个问题：
	找不到demo  因为 Demo 和test 不在同一个包下
第二个问题：
	程序包coim.liuyi 不存在  ，要先对DEmo 进行编译生成class文件
第三个问题
	Demo在com.liuyi中不是公共的; 无法从外部程序包中对其进行访问
	
com.liuyi.Demo  d = new com.liuyi.Demo();

导包
	概述{不同包下类之间的访问，我们发现，每次使用不同包下类的时候，都需要加包的全路径，比较麻烦，java提供了导包的功能}
	导包格式：
		import 包名；
	注意：
		这种方式导入是到类的名称
		虽然最后可以写*  但是不建议
	
		package import class 的顺序关系
		package >  import > class 
		package  :只能有一个
		import : 可有有多个
		class : 可以有多个，以后建议由一个

	权限修饰符：
	      			  	 public      protected         默认      private
同一类中 					+           +               +           +

同一包子类，其他类          +           +               +

不同包子类                  +           +
 

不同包其他类                +



同一个包下的子类。和无关类，可以访问私有以外的方法


修饰符
权限修饰符：private 默认 protected public
状态修饰符： static  final
抽象修饰符：abstract 
类：
	默认修饰符   public 
	final 
	abstract
	用的最多的是  public
成员变量：
	private 默认 protected public
	static  final
	用的最多的是  private
构造方法
	private 默认 protected public
	用的最多的是 public
成员方法：
	private 默认 protected public
	static final
	abstract 
	用的最多的是  public 

除此以外的组合
成员变量：public static final 
成员方法：public static
		  public abstract
		  public final

		  内部类概述
	{把类定义在其他类的内部，这个类就被称为内部类}
	举例：在类A中 定义一个 类B 类B就是内部类
	内部类的访问特点
	内部类可以直接访问外部类的成员，包括私有
	外部类要访问内部类的成员，必须创建对象


内部类的位置：

如何直接访问成员内部类的成员

外部类名.内部类名 对象名=外部类对象.内部类对象
Outer.Inner oi=new Outer().new Inner()

注意：但是在开发中一般不这样使用，因为一般内部类就是不让外界直接访问的
举例：Body 和 Heart  电脑和CPU 

成员内部的常见修饰符：
	private  为了保证数据的安全性
	static  为了让数据访问更方便
		被静态修饰的成员内部类只能访问外部类的  静态成员
		内部类方法被静态修饰后的方法
		静态方法
		非静态方法

		//成员内部类被静态修饰后的访问方式是：
		//格式 ：外部类名.内部类名 对象名=new 外部类名.内部类名（）；


内部类访问外部类的成员变量
格式1：new 外部类名（）.变量名；
格式2： 外部类名.this.变量名；

		System.out.println(this.num);
			//System.out.println( new Outer().num);// 
			//通过外部类名。限定this对象
			System.out.println(Outer.this.num);

局部内部类：
可以直接访问外部类的成员
可以创建内部类的对象，通过对象调用内部类方法，来使用局部内部类功能

局部内部类访问局部变量的注意事项：
必须被final修饰？
原因：
	因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有马上从堆内存中消失，
	还要使用这个变量。为了让数据还能继续被使用，就用final修饰，这样在堆内存中存储的其实是
	一个常量，通过反编译工具可以了解到

	
为什么局部内部类对象访问局部变量时要加final关键字？
说到底是因为生命周期的不同。
局部内部类需要GC调用才能回收，而局部变量在对应的栈帧出栈即被抛弃。
因此有可能还存在的局部内部类对象去访问一个根本已经不存在的局部变量，这是不被允许的情况。
因此，无奈之下，只能加上final关键字来修饰局部内部类对象调用的局部变量。
在1.8版本的jdk中不需要添加fianl关键字了，但是只是假象，编译的时候还是会隐式的添加。
而且1.8中局部内部类对象中不能对局部变量进行修改，也就是说隐性的具有final的语义。

对象是在垃圾回收器空闲的时候才会被回收 


匿名内部类
	就是内部类的简化写法
前提：存在一个类或者一个接口
	这里的类可以是具体类也可以是 抽象类
格式：
	new 类名或接口名（）{
	重写方法；
	};

本质：new 是在内存中分配内存，其本质不是类而是一个对象，
该类或者该抽象类的子类或者该接口的实现类的对象。因为只有子类才会去重写方法，而且该


是一个继承了该类或者实现了该接口的子类匿名对象

匿名类中方法的实现方式
一个方法的调用方式
1 new 类名或者接口名（）{
	重写方法；
}.方法名
多个方法的调用方式
父类名 对象名=new 类名或者接口名（）{
	重写方法1；
	重写方法2；
	...
}；
对象名.方法名（）；
对象名.方法名2（）；
...

匿名内部类在开发中的作用；
首先回顾我们曾经讲过的方法的形式参数是引用类型的情况，重点是接口的情况
我们这里需要一个子类对象，而匿名对象类就是一个子类匿名对象，所以使用
匿名内部类改进以前的做法


/ Outer.method()说明method 是静态方法,
		//并且 method 方法有返回值是 接口的实现类的对象


IDE ：integrated development environment  集成开发环境

//http://eclipse.org/    org  免费    com  商业

eclipse 空间的配置
如何显示行号
在代码区域的最左侧的空白区域，右键  --  show line number 


A 程序的编译和运行的环境配置
Window--->  preferences--->java
编译环境  ：compiler 默认选中的就是最高版本
运行环境 ：installsed   JRE  默认会找到你安装的那个JDK 建议配置java的环境变量
问题：
低编译  高运行  可以
高编译  低运行  不可以
建议：编译和运行的版本一直


如何去掉默认的注释
 window -->preferences -->java --> code style  -->code Templates
 选择你不想要的内容 通过右边 edit 编译器

 注意：只删除注释部分，不是注释部分的不要删除

 窗口乱了
 window --》reset  perspective

 控制台找不到<>
 window-->show view-console

  alt+/  内容辅助
  提示作用

  Ctrl +shift +f 格式化
  Ctrl + shift + o 导包
  如果该类只在一个包中有，就直接导包了，如果在其他包中也有，就需要再进行选择

  注释：
  单行注释
  Ctrl + /
  取消注释再来一次

   多行注释
   Ctrl +shift +/
   取消多行注释 
   Ctrl+shift +\

   代码上下移动
   选中代码 alt + 上下箭头

 查看原码
 选中类名（F3 或者 Ctrl+鼠标点击）

无参构造方法  
	在代码区域右键 -- source--generate construction from superclass 
带参构造方法
	在代码区域右键--source--generate construction usingfields 。。
成对的getXX（）  setXX（）
	 在代码区域右键--source--generate getters and setters..

快捷键操作 
	

 jar  包



   导入项目
   在项目区域右键找到import 
   找到 general 展开 并找到 
   existing projects into workspace 
   点击next 然后选中要导入的项目

   注意：这里 选择的是项目名称

   导入项目中的小问题
   如何查看项目所在路径
   		选中  --右键 --properties--resource --location
   导入项目要注意的问题
	   项目区域中不能出现同名的项目（新建或者导入）
	   自己随意建立的文件夹是不能作为项目导入的(正常建立的文件，是有两个自动配置文件的)

   修改项目问题
	   不要随意修改项目名称
	   如果真要修改，不要忘记配置文件.project 中的
	   <name>把这里改为修改后的名称</name>


		eclipse 中代码的高级（debug）调试
		debug 的作用
		调试程序
		查看程序执行流程
		步骤：
	断点：就是一个标记从哪里开始

	如何设置断点位置：
	在有效程序的左边，双击（一般是在main 方法中）

	目前：我们都是在每个方法的第一条有效语句上加

	如何运行设置断点后的程序
		右键 -- debug as --java Application 
		
		看哪些地方：
		debug 视图
		debug   ； 断点测试的地方 
		F6 或者 点击也行，一次看一行的执行过程《step over》

		variables ；查看程序的变量变化

		fordemo；被查看的源文件

		console：控制台
如何去掉断点
	A：再次双击即可
	B：debug 视图的 variables 界面 printpoint  全选，右侧 两个XX 图标点击，移除所有的断点


常见对象：
API---常用类
（Application Programming interface）应用程序编程接口
就是JDK 提供的帮助简化编程的东西

编写一个机器人程序去控制机器人踢足球，程序就需要向机器人发出向前跑，向后跑，射门等各种命令，对于有开发经验的人员说，这道机器人厂商一定会提供一些关于控制机器人的java类，这些类定义好了操作机器人的各种动作的方法，其实这些java类就是机器人厂商提供给应用程序编程的接口，


 
 hashcode()
 会针对不同的对象返回不同的整数，（一般是通过将该对象的内部地址转换成一个整数类实现的，但是java编程语言不需要这种实现技巧）
 返回：此对象是一个哈希值
 public int hashcode（）
 返回该对象的哈希码值，支持此方法是为了提高哈希表的性能
 实际上，由object类定义的hashCode 方法确实会针对不同的对象返回不同的整数（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是java编程语言不需要这种实现技巧）

 getclass()  返回此object的运行时类。返回class对象是由所表示类的static synchronized 方法锁定的对象

 tostring()方法
 toString()方法自动生成
 右键--source--generate toString()
 注意：
 直接输出一个对象的名称，其实就是调用该对象的toString() 方法



 Scanner   jdk5 以后
 public final class Scanner extends Object implements Iterator(String)

   
eclipse 组成的视窗个视图
视窗  每一个基本的窗体被称为视窗
packageExplorer  显示项目结构、包、类、及资源
Outline 显示类的结构、方便查找、识别、修改
Console 程序运行的结果在该窗口显示
Problem 显示所有语法及错误所在的位置
Hierarchy 显示java继承层次结构，选中类后F4
视图   是由某些视窗的组合而成的，例如   java视图  debug 视图

alt+/ 内容辅助键
 * mian 方法
 * main +alt+/
 * 输出语句
 * syso +alt +/
 * 提示作用
常用快捷键


override  是注解，表示这个方法是重写父类的，如果和父类名出现了偏差，

eclipse 中如何制作帮助文档

编写源程序（设计接口，抽象类，具体类案例）
针对源程序添加文档注释
选中项目--右键--Export--java--Javadoc--Finish

jar

jar 是什么？jar是多个class 文件的压缩包
jar有什么用？ 用别人写好的东西
打jar包  选中项目--右键--export --java--jar--自己指定一个路径和一个名称--finish 
 使用jar包   复制到项目路径下并添加至构建路径

 选中要导入jar包的项目--右键--new--folder --复制要导入的jar包--在folder下粘贴，选中jar包，--
 右键--build path --add to build path

在eclipse中如何删除项目  选中  右键 delete 【delete project contents on disk （cannot to undone）】<从硬盘中删除，不能撤销>、

导入项目

==：
	基本类型：比较的就是值是否相等
	引用类型：比较的就是地址值是否相等

equals :
	引用类型：默认情况下，比较的是地址值
	不过，我们可以根据自己重写该方法，一般重写都是自动生成，比较对象的成员变量值是否相同


finalize ()
当垃圾回收器确定不存在对该对象的更多引用时，
由对象的垃圾回收器调用此方法。子类重写 finalize 方法
，以配置系统资源或执行其他清除。 
finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法
再通过任何方法访问此对象时，将调用此方法，
除非由于准备终止的其他某个对象或类的终结操作执行了某个操作。
finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；
不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。
例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，
以便在永久丢弃对象之前中断连

object 类的finalize 方法执行非特殊性操作，它仅执行一些常规返回。object 的子类可以重写此方法。

protected Object clone()创建并返回此对象的一个副本，
* A  重写该方法 
* Cloneable 接口 是没有方法的接口，叫做标记接口。告诉我们实现该接口的类就可以实现对象的复制了
* 此类实现了Cloneable 接口，以指示Object.clone() 方法可以合法的对该类实例进行按字段复制
* 

string 类
多个字符组成的一串数据，也可以看成是字符数组。


字符串（字符数组）
字符串是常量，他们的值在创建之后不能更改。
字符串缓冲区支持可变的字符串（在缓冲区是另一个对象），因为string对象是不可变的，所以可以共享。
字符串的两个特点：字符串字面值“ABC”也可以看成是一个字符串对象
				  字符串是常量，一旦被赋值，就不能被改变。
	构造方法：
	public String()   空构造
	public String(byte[] bytes) 把字节数组转成字符串
	public String(byte[] bytes,int index,int length)
	在字节数组中从某个索引值开始，将几个数组元素转成字符串
	public String(char[] value) 把字符数组转化成字符串
	public String(char[] value,int index, int count)
	在字符数组中，从某个索引值开始，将几个数组元素转化成字符串
	public String(String original) 把字符常量转化成字符串



public String toString()
返回该对象的字符串表示。通常， toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。
Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：

 getClass().getName() + '@' + Integer.toHexString(hashCode())       



注意事项：
   字符串如果是变量相加，是先开空间，再拼接
	字符串如果是常量相加，先相加，然后在常量池中找，如果有就直接返回，
		否则，就创建	

String  类的判断功能
	boolean equals(Object obj)
		这里str是一个用来与调用字符串（String）对象做比较的字符串（String）对象。
		如果两个字符串具有相同的字符和长度，它返回true，否则返回false。这种比较是区分大小写的

	boolean equalsIgnoreCase(String str)														    这里，str是一个用来与调用字符串（String）对象做比较的字符串（String）对象。
			如果两个字符串具有相同的字符和长度，它也返回true，否则返回false

	boolean contains(String str)
	boolean startsWith(String str)
	boolean endsWith(String str)
	boolean isEmpty()
	
step into 	就是单步执行，遇到子函数就进入并且继续单步执行；

step over 	是在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，
			而是将子函数整个执行完再停止，也就是把子函数整个作为一步。
			
step return 就是单步执行到子函数内时，
			用step return就可以执行完子函数余下部分，并返回到上一层函数。


String 类的获取功能

int length()获取字符串的长度
char charAt(int index)获取指定索引位置的字符
int indexOf(int ch) 返回指定字符在此字符串中第一次出现处的索引
	为什么这里是int类型，而不是char 类型
	原因是：‘a’和97其实都可以代表'a'
int indexOf(String str) 返回指定字符串在此字符串中第一次出现的索引


int indexOf(int ch,int fromIndex) 返回指定字符在此（字符串第一个字符的位置开始）字符串中从指定位置后第一次出现处的索引
int indexOf(String str,int fromIndex)返回指定字符串在此字符串中从指定位置后第一次出现处的索引
String substring(int start) 从指定位置开始，截取字符串，包含start位置的字符。
String substring(int start,int end)  从指定位置开始到指定位置结束，截取字符串

字典顺序  abcde~~z就是字典顺序

替换功能： 
String replace(char old,char new)
String replace(String old,String new)

去除字符串两空格
String trim()

按字典顺序比较两个字符串
int compareTo(String str)
int compareToIgnoreCase(String str)


String 的转换功能
byte[] getBytes()  //把字符串转成字节数组。通过构造方法可以把字节数组转成字符串，
						所以字节数组和字符串是可以相互转换的
char[] toCharArray()  //把字符串转换成字符数组  遍历字符串的另外一种方式
static String valueOf(char[] chs)  //把字符数组转化为字符串
static String valueOf(int i)   // 把int类型的数据转成字符串
注意：
	String 类的valueOf 方法可以把任意类型的数据转成字符串

String toLowerCase()   //把字符串转成小写
String toUpperCase()   //把字符串转成大写
String concat(String str)    // 把字符串拼接

字符串的其他功能
String replace(char old,char new);
String replace(String old,String new);

去除字符串两端的空格

String trim()  //去除字符串两端的不去除中间的空格


StringBuffer  线程安全的可变字符序列
线程安全(多线程讲解)
安全 ---同步--数据是安全的
不安全--不同步--效率要高一些
安全和效率问题是永远困扰我们的问题，不能同时兼得，只能尽量兼顾
安全：医院的网站，银行的网站
效率：新闻网站，论坛类网站

StringBuffer 和 String的区别
前者内容和长度可变，后者不可变
如果使用前者字符串的拼接，不会浪费太多的资源

构造方法
StringBUffer() 构造一个其中不带字符的字符串缓冲区，其初始容量为16个字符
StringBuffer(CharSequence seq) 构造有个字符串缓冲区，它包含与CharStrig 相同的字符
StringBuffer(int capacity) 构造有个不带字符，但具有指定初始容量的字符串缓冲区
StringBuffer(String str) 构造有个字符串缓冲区，并将其内容初始化为指定的字符串内容
StringBuffer  的方法
public int capacity（）  返回当前的容量   理论值
public int length （）   返回长度（字符数） 实际值

选择排序
		原理：从0 索引开始，一次和后面的元素进行比较，小的往前面放，第一次比较完毕，最小值出现在最小索引处，其他的同理既可以得到一个拍好序的数组
	规则：
		1 第一次从0 索引开始和其他的进行比价
		  第二次从1 索引开始和其他的进行比较
		  。。。
		2 最后一次是 数组长度- 2 和数组长度-1 的元素进行比较

查找法
基本查找，数组元素无序，从头查到尾。没有就返回-1 

二分查找（折半查找），要求数组有序
思想：每次都猜中间，比较大还是小，就能减少一半的元素


注意： 如果数组是无序的，不能使用二分查找。
		如果先进行排序再查找就改变了数组原始的元素索引
		所以，此时只能进行基本的查找方法

Arrays 类的概述
此类包含用来操作数组（比如排序和查找）的各种方法。
此类好包含一个允许将数组作为列表来查看的静态工厂

除非特别注明，否则如果指定数组的引用为null。此类中的方法都会抛出  nullPointerException

Arrays 工具类的排序方法，底层就是快排  quick Sort
为对基本数据类型进行更多的操作，更方便的操作，java就针对每一种数据类型提供了对象的类类型。
包装类类型
byte   Byte
short  Short
int   Integer 
long Long 
float  Float
double   Double 
char    Char 
boolean   Blooean
常见的操作之一，就是基本数据类型与字符串之间的转换
integer
integer 类在对象中包装了一个基本类型int值。integer 类型的对象包含一个int类型的字段

此外，该类提供了多个方法，能在int类型和String类型之间进行转换。还提供了处理int类型时非常有用的其他的一些常量和方法

Integer 的构造方法
* public Integer(int value)
* public Integer(String s)
此处的String是数字的不能是字母的

integer.parseInt()

进制准换的范围   2~  36
因为  2  可以用0,1 表示
0~9   a~z总共36 个数

十进制到其他进制
 public static String toSTring (int i,int radix);
 Integer.toString(100,3);
 其他进制到十进制

Integer.paresInt("100",8);

 JDK 1.5 以后，简化了定义方式
 Integer x= new Integer（4）；可以直接下城
 Integer x = 4 ; 自动装箱
 x = x + 5 ； 自动拆箱   通过intValue 方法
 特备注意
 在使用时，Integer  x = null; 上面的代码就会出现   NullPointerException 

Integer  的面试题

byte 常量池  -128   ~   127  
通过查看原码，可以看到，针对 -128 到127 之间的数据，做了一个数据缓冲池，
Integer i1 = Integer.valueOf(127)
如果数据是该范围内的，每次并不创建新的空间
Integer i2 = 128 ;又重新创建了空间

所以  Integer 的数据直接赋值，如果在-128 到127 之间会直接从缓冲池中提取数据

Character  类在对象中包装一个基本类型char 值，Charater类型的对象包含类型为char 的单个字段
此外，该类提供了几种方法，以确定字符的类别（小写字母。数字。等等），并将字符从大写转换成小写，。反之亦然
类成员方法
判断给定的字符是否是大写，小写，数字字符
public static boolean isUpperCase(char ch)
public static boolean isLowerCase(char ch)
public static boolean isDigit(char ch)
把给定的字符转换为大写，小写字符
public static char toUpperCase(char ch)
public static char toLowerCase(char ch)

正则表达式（符合某个正确规则的表达式）【符合一定规则的字符串】
是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。
其实就是一种规则，有自己特殊的应用


	  public boolean matchs(String regex)
      告知此字符串是否匹配给定的正则表达式

正则表达式的组成规则
规则字符在java.util.regex Pattern 类中
常见组成的规则
字符
字符类
预定义字符类
边界匹配器
数量词

字符
x 字符 x  。举例 ‘a’表示字符a
\\ 反斜线字符
\n 新行（换行）符（‘\u000A’）
\r 回车符（‘\u000D’）
 B  字符类
 [abc] a、b、或c  (简单类)
 [^abc] 任何字符，除了a、b、或c （否定）
 [a-zA-Z] a到z 或 A到Z。两头的字母包括在内（范围）
 [0~9] 0 到 9 的字符都包括

 C 预定义字符类
 . 任何字符，如果是. 本身，就用\.
 \d 数字：[0-9]
 \w 单词字符：[a-zA-A_0-9]
 在正则表达式里面组成单词的东西必须有这些东西组成

 D： 边界匹配器
 	 ^  行的开头
 	 $ 行的结尾
  	\b 单词边界（就是不是单词字符的地方）
  	hello world? hah:xixi
E 数量词
X? X，一次或一次也没有
X*  X，零次或多次（包括一次）
X+  X,一次或多次（至少一次）
X{n}  X 恰好n 次
X{n, } X 至少 n次
X{n,m} X 至少n 次 ，但不会超过m 次

正则表达式的应用
判断功能
public boolean matches(String regex)
分割肺功能
public String[] split(String regex)
替换功能
public String replaceAll(String regex.String replacement)
获取功能
Pattern 和 Matcher 类的使用  
指定为字符串的正则表达式必须首先编译为此类的实例。然后，可将得到的模式用于创建Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配，执行匹配所涉及到的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一个模式

调用的顺序是
pattern p = Pattern.compile("a+b");
Matcher m = p.matcher("aaaab");
boolean b = m.matcher();

注意：
 String s = "gfiwt dkjt fji few ";
String regex= "\\w{3}";
Pattern p = Pattern.compile(regex);
Matcher m = p.matcher(s);
boolean flag = m.find();
String ss = m.group();
一定要有find()  然后才能有group()

Math 类
包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数
 成员变量：
 	public static final double pi
 	public static final double e\
 成员方法
 	public static double ceil(double a) 向上取整
 	public static int abs(int a)  绝对值
 public static double floor(double a)  向下取整
  public static int max(int a,int b) min（自学） 最大值
  public static double pow(double a,double b) 返回第一个参数的第二个幂次数
   public static int round(float a) 参数类型为 double 的自学 四舍五入
   public static double sqrt(double a) 返回 a 的正平方根
   
Random 类
此类用来生成（伪）随机数流，此类使用48 位的中子，使用线性同余公式。对其进行修改。
构造方法
Random() 创建一个新的随机数生成器
Random(long seed)  使用单个long 种子创建一个新的随机数生成器
但是，很多程序会发现，Math.random 更容易应用

构造方法
* 	public Random();没有给种子，用的是默认种子，是当前时间的毫秒值
* 	public Random(loog seed);给出指定的种子
* 给定种子后，每次得到的随机数是相同的。
* 成员方法
* 	public int nextInt();返回的是int范围内的随机数
* 	public int nextInt(int n);返回的是 [0,n)的范围内的随

System类  包含了一些有用的类字段和方法[说明其字段和方法都是跟类相关的，即是静态的，没有构造方法]，不能被实例化，因为不粗要。是final 类，最终类。
成员方法
		public static void gc()
		public static void exit(int status)
		public static long currentTimeMillis()
		public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)


System.gc()  可用于回收垃圾。当使用System.gc()回收某个对象所占用的内存之前，
通过要求程序调用适当方法来清理资源。在没有明确之指定资源清理的情况下，
java提供了默认的机制来清理该对象的资源，就是调用object类的fianlize()方法。
finalize()方法的作用是释放一个对象占用的内存空间，会被JVM调用。而子类重写该方法，
就可以清理对象占用的资源，该方法没有连式调用，所以必须手动实现。
从程序的运行结果看，执行System.gc()之前，系统会自动调用fianlize()方法清除对象占有的资源，
通过super.finalize()方式可以实现从下到上的finalize() 方法的调用，即先释放自己的资源，再去释放父类的资源。

但是，不要在程序中频繁的调用垃圾回收，因为每一次执行垃圾回收，JVM 都会强制启动垃圾回收器运行，
这会耗费更多的系统资源，会与正常的java程序运行争抢资源，只有在执行大量的对象的释放，才会调用垃圾回收最好。

BigInteger 类



        Integer iii = new Integer("2147483648");
		//NumberFormatException  已经超出了。Integer能表示的最大范围
		System.out.println(iii);
		//无法进行大数据的运算


public BigInteger add(BigInteger val)       加
public BigInteger subtract(BigInteger val)  减法
public BigInteger multiply(BigInteger val)  乘法
public BigInteger divide(BigInteger val)    除法
public BigInteger[] divideAndRemainder(BigInteger val)  返回商和余数的数组


BigDecimal由于在运算的时候。float类型和double类型很容易丢失精度，演示案例，所以，为了能精确的表示，计算浮点数，java提供了bigdecimal 

不可变的，任意精度的有符号十进制数.可以解决精度丢失问题

构造方法  public bigdecimal(string val)



Date 类的概述
类 Date 表示特定的瞬间。精确到毫秒
canlender
Date ===String (格式化)
String --Date （解析）
DateForamt:可以进行日期和字符串和解析，但是由于是抽象类，所以使用具体子类SimpleDateFormat 
simpleDateFormat的构造方法：
SimpleDateFormat


时间毫秒值   毫秒值时间

calender 抽象类 它为特定瞬间与一组诸如YEAR。MONTH，DAY_OF_MONTH， HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法
puvblic static Calendar getinstance()
public int get(int field)
public void add(int field ,int amount)  根据给定的日历字段和对应的时间，来对当前的日历进行操作

public final void set(int year,int month,int date) 设置当前日历的年月日

集合类概述
为什么会出现集合类
面向对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，就需要对多个对象仅此昂存储，而想要存储多个对象，就不能是一个基本的变量。而应该是一个容器类型的变量，在我们目前所学过的知识里面，容器类型的有数组和StringBUffer 但是，StringBuffer 的结果是一个字符串，不一定满足要求，所以只能是数组，即对象数组，而对象数组又不能适应变化的需求，因为其长度是固定的，所以java就提供了集合类

数组和集合类同是容器。，有何不同
数组虽然也可以存储对象，但是长度是固定的，集合的长度是可变的，数组中可以存储基本数据类型，而集合只能存储对象

数组存储的是同一种类型的元素，
而集合可以存储不同类型的元素

集合类的特定
集合只能存储对像，集合长度是可变的，集合可以存储不同类型的对象

集合的存储是多员的，但是呢，存储多个元素我们是有不同的需求的，比如说，我要这个多个元素中不能有相同的元素，再比如说，我要这个元素按照某种规则排序一下，
针对不同的需求，java就提供了不同的集合类，所以，java提供了很多个集合类，这多个集合类的数据结构不同。结构不同不重要，重要的是要能够存储东西，并且能够使用它们。 

数据结构：数据的存储方式。

Collection <E>    1.2版本
集合的顶层接口，其子体系有重复的，有唯一的，有有序的，有无序的等
Collection <E>
功能描述
	添加功能 
		boolean add(Object obj):添加一个元素
		boolean addAll(Collection c) 添加一个集合
	删除功能
		void  clear() 移除所有元素
		boolean remove(Object obj):移除一个元素
		boolean removeAll(Collection c) 移除一个集合的元素，只要有一个被移除，就返回true
	修改功能
		boolean contains(Object o) 判断集合中是否包含指定的元素
		boolean containsAll(Colleation c) 判断集合中是否包含指定的集合元素  全部包含，返回true
		boolean isEmpty() 判断集合的元素是否为空
	获取功能
		Iterator<E> iterator() {重点}
	长度功能
		int size() 元素的个数
	交集功能
		boolean retainAll(Collection a)两 		个集合中都有的元素，需要注意的是，元素去哪里了<相同的元素去了C1 >，返回的布尔值又是什么意思<true , >  
		假设有两个集合A和B
		A对B做交集，最终的结果保存在A中，B不变
		返回值表示A是否发生改变，如果A发生改变，则返回真，如果A 未发生改变，则返回假


			把集合转为数组
			Object[] toArray()


注意：ColletionXxx.java 使用了未经检查或不安全的操作
注意： 要了解详细的信息，请使用-Xlint:unchecked 重新编译
java编译器认为该程序存在安全隐患，具体分析，等到反泛型



Collection 接口成员方法
把集合转成数组，可以实现集合的遍历
terator iterator()
迭代器，集合的专用遍历方式



 Iterator iterator()
 迭代器  集合的专用遍历方式
 获取元素,并移动到下一个位置:Object next()  
 noSuchElementException  没有这样的元素，因为已经找到最后的元素了

注意：不要多次调用it.next()方法
Student s = (Student) it.next();
System.out.println(s.getName()+"    "+s.getAge());
\
System.out.println(((Student) it.next()).getName()+"    "+((Student) it.next()).getAge())
//该方法是调用的第一次的名字，第二次的年纪，第三次的名字，第四次的年纪，依次类推

迭代器的原码
public interface Iterable{
	Iterator iterator();
}
public interface Inteator{
	public abstract boolean hasNext();
	public absract Object next();

	
}
public interface Collection extends Iterator{

	
}

public interface Collection extends Collection{
	
}

public class ArrayList implements LIst{
	Iterator iterator();
}
public interface Collection extends Iterable{
	
}
public interface List extends Collection{
	
}
public class ArrayList implements List {
	public Iterator iterator(){
	return new Itr();
	}
	private class Itr implements Iterator{
	public boolean hasNext();
	public Object next(){}
	}
}

Collection c = new ArrayList();
c.add("hello");
c.add("world");
c.add("java");

 Iterator it = c.iterator();  //new Itr();
 while(it.hasNext()){
 	String s = (String )it.next();
 	System.out.plrintln(s);

 	

 }

 list  集合的特点

collection 是有序的，是指，以张三李四王五的顺序进来，也以张三李四王五事物顺序出去
和排序 不是一个概念
此接口的用户可以对列表中的么一个元素进行精确的控制，用户可以根据元素的整数索引，（在列表中的位置）  访问元素，并搜索列表中的元素

List 的特有功能
* A 添加功能
* 		在指定位置添加元素
* 		void add(int index,Object element)
				在当前索引值的下一位就没有问题，否则就会越界
* B 获取功能
* 		Object get(int index)获取指定位置的元素，获取后对原来的数组没有影响

* C 列表迭代器 是list集合特有的迭代器
* 	    ListIterator listiterator() 
*  D 删除元素
*  	    Object remove(int index)根据索引删除元素，返回被删除的元素
*  E 修改功能
*  		Object set(int ijndex,Object element) 根据索引修改元素，返回被修改的元素



列表迭代器
该迭代器，继承了iterator () 迭代器，所以，就可以使用hasNext()  next() 方法

previous()。返回，取前一个元素
hasPrevious()/判断前面是否有元素
但是，需要注意：
如果要逆向遍历，首先要正向遍历，然后才能逆向遍历。但是，一般意义不大


//ConcurrentModificationException0
//当方法检测到对象的并发修改时，但不允许修改时，就会【抛出这种异常
产生的原因“
	迭代器是依赖于集合而存在的，在判断成功后，集合中新添加了元素，而迭代器是不知道的，所以就报错，这个错误就是并发修改异常
	其实这个问题描述的是，迭代器在遍历元素时，通过集合是不能修改元素的
解决方法
	1 迭代器迭代元素，迭代器修改元素
	2 集合迭代元素，集合修改元素（普通的for循环）

针对第一种的方法 
	iterator 迭代器没有添加功能，所以我们就使用其子接口 listIterator ()



常见的数据结构
栈
队列
数组
链表
树
哈希表

list 的子类特点
	ArrayList()
	底层是数组，查询快，增删慢
	线程不安全，效率高
	Vector()
	底层数据结构是数组，查询快，增删慢
	线程安全，效率低
	已经不常用，已经有替代的方式
	LinkedList()
	底层数据结构是链表，查询慢，增删快
	线程不安全，效率高
三个子类，选择的方式，看需求
ArrayList 的特有各功能
vector的特有功能
 添加工鞥能
 public void addEliment(Object obj)------add()
 获取功能
 public Object elementAt(int index)------get(x)
 public Enumeration elements()---- Iterator iterator()
 	boolean hasMoreElements()-------hasNext()
 	Object nextElement() ---------next()      

LinkedList 的特有功能
contains 方法的底层依赖的是equals方法
而，学生类中没有equals方法，这个时候默认使用的父亲Object的equals方法
Object 的equals默认比较的是地址值，所以，会造成遗漏，因为new的地址值都不相同
比较成员变量的值，需要重写eauals 方法

泛型
	是一种把类型明确的工作推迟发哦创建对象或调用方法的时候才去明确的特殊类型
	参数化类型，把类型当做参数一样的传递

格式
	<数据类型>  此处的数据类型只能是引用类型
好处：
	把运行时期的问题提前到了编译期间
	避免了强制类型转换
	优化了程序设计，解决了黄色警告线
使用场所
	一般是在集合中使用
泛型的盈盈
泛型类
	把泛型定义在类上
	格式：public class类名<泛型类1，泛型类2 。。。>
	注意：泛型类型必须是引用类型
泛型方法
	把泛型定义在方法上
	格式:public <泛型类型> 返回类型 方法名（泛型类型）
泛型接口
	泛型定义在接口上
	格式：public interface 接口名<泛型类型1，泛型类型2.。。   >

泛型  ---通配符
三种
？：  表示任意的类型都可以

？ extends E : 向下限定，E及其子类

? super E : 向上限定，E及其父类

JDK5 的新特性
自动拆装箱
泛型
增强for
静态导入
可变参数
枚举
格式：
for（元素数据类型 变量：数组或Collection集合）{
	使用变量即可，该变量就是元素
}
优点：
    简化了数组和集合的遍历
弊端：
增强for的目标不能是null 
解决方法
	对增强for的目标先进行不为null 的判断，然后再使用

增强for其实是用来替代迭代器的

静态导入
格式
import static 包名...,类名，方法名；
可以直接导入到方法的级别
import static java.lang.Math.abs;
System.out.println(abs(-199));
注意事项
	方法必须是静态的
	如果有多个同名的金塔方法，容易不知道使用谁，这个时候要使用，必须加前缀，由此可见，
	意义不大，所以，一般不使用，但是要求能看懂
	
可变参数【定义方法的时候不知道该定义多少个参数】
格式：	
	修饰符返回值类型  方法名（数据类型。。。变量名）{

	}
注意
	这里的变量其实是一个数组
	如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个。
Arrays 工具类中一个方法
	public static<T>List<T>asLIst(T...a)

public static int sum(int... a){
	//System.out.println(a);
	//a 其实是一个数组
	int s = 0;
	for(int x:a){
	s +=x;
	}
	return s;
}
以上是可变参数求和


 集合的toString 方法
 Collection c = new ArrayList();
 c.add("hello");
 c.add("world");
 c.add("java");
 System.out.println();
 为什么c 输出的不是地址值
 	A collection c = new ArrayList()
 	是多态，所以输出c 的tostring 方法，其实是输出ArrayList的toString 
 	B 看ArrayList的toString 
 		而我们在ArrayList里面却没有发现。toString 方法。应该是在其父类中

 	c toString 方法原码
 	public String toString(){
 	Iterator<E> it =this.iterator();//集合本身调用迭代器方法
 	if(! it.hasNext())
 	return "[]";

 	StringBuilder sb = new StringBuilder();
 	sb.append('[');
 	for(;;){//最简单的死循环
 	E e = it.next();
 	sb.append(e==this ? "(this Collection)": e);
 	if(! it.hasNext()){
 	return sb.append(']').toString();
 	sb.append(',').append('');
 	}
 }
} 

set<E> 概述  增强for 迭代器
不包含重复元素，

hashset 它不保证set的迭代顺序，特别是它不保证该顺序恒久不变
虽然set集合的元素无序，但是，作为集合来书说，它肯定有自己的存储顺序，e
而不得顺序恰好和它的存储顺序一致，这代表不了有序，你可以多存储一些数据，就能看到效果
hashset如何保证元素的唯一性
底层数据结构是哈希表（元素是链表的数组）
哈希表依赖于哈希值存储
添加功能底层依赖两个方法
int hashCode()
boolean equals(Object obj)
通过查看add方法的原码，这个方法的底层依赖两个方法：hashCode() 和 equals()
步骤：	
	首先比较哈希值
	如果相同，继续走，比较地址值或走equals（）
	如果不同，就直接添加到集合中
按照方法的步骤，
	A 先看hashCode 的值是否相同
	相同
		继续走equals 方法，
		返回true，说明元素重复，就不添加
		返回false 说明元素不重复，就添加到集合
		不同
		就直接把元素添加到集合
如果类没重写这个方法，默认使用OBject的，一般来说不会相同
而String类重写了hashCode （）和equals （）方法，所以，它就可以把内容相同的字符串去掉，只留一个

哈希表：一个元素为链表的数组，综合了数组和链表的好处


LinkedHashSet 类概述  具有可预知迭代顺序的set接口的哈希表和链接列表实现
数据结构有哈希表和链表
元素有序唯一
由链表保证元素有序
有哈希表保证元素唯一

TreeSet 概述
基于treeMap 的NavigableSet实现  使用元素的自然排序对元素进行排序
或者根据创建set 时提供的Comparator 进行排序（比较器排序），具体取决于使用的构造方法


如果一个方法的参数是接口，那么真正乣的是接口的实现类的喜爱你个
而匿名内部类就可予以实现这个东西

TreeSet 集合保证元素排序和唯一性的原理
唯一性：是根据比较的返回是否是0 来决定的
排序：
	自然排序
		让元素所属的类实现自然排序接口Comparable
	比较排序
		让集合构造方法接收一个比较器接口的子类对象Comparator























