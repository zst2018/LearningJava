

# IO流----异常

> ###**[数据永久性存储]**
>
> ### **1.异常 [角标越界异常，空指针异常]**
>
> ### 		异常就是java程序在运行过程中出现的错误，其实就是java对不正常情况进行描述后的对象体现
>
> ###**程序的异常分类： Throwable**
>
> > **1 严重问题，Error**
> >
> > ​	Error 是Throwable 的子类，是用于只是合理的应用程序不应该试图捕获的严重问题。
> >
> > ​	针对这种问题，一般我们不处理，比如说  内存溢出。
> >
> > **2 一般问题，Exception**
> >
> > > **编译期问题  不是RuntimeException的异常**
> > >
> > > ​	这种问题是必须要处理的，因为，如果不处理，编译就不能通过。
> > >
> > > 运行期问题  RuntimeException   
> > >
> > > ​	这种问题我们也不处理，而且这种问题的出现
> > >
> > > ​	一般都是我们的代码不够严禁，需要修正代码的。
>
> > **如果程序出现了问题，我们没有左任何处理，最终JVM会做出默认的处理。**
> >
> > ​	把异常的名称，原因及出现的问题等信息输出在控制台。
> >
> > ​	同时结束程序
> >
>
> ​		**我们自己如何处理运行时异常呢？**
>
> > >>注意：
> > >>
> > >>     	1. **try里面的代码越少越好，因为放在try里面的代码，就要走异常处理机制，需要	java虚拟机开辟一些新的资源来管理，故try里面的代码越多，就需要越多的资源来处理它。**
> > >>      2. **catchl里面必须有内容，哪怕是给出一个简单的提示，否则就不是处理问题而是隐藏问题，没有意义。**
> > >
> > >> **两个异常的处理：**
> > >>
> > >>  *  每一个写一个try...catch 
> > >>
> > >>  *  **写一个try，多个catch**
> > >>
> > >>     ```java 
> > >>     try{
> > >>       ...
> > >>     }catch(异常类名 变量名){
> > >>       ...
> > >>     }catch(异常类名 变量名){
> > >>       ...
> > >>     }
> > >>     ```
> > >
> > >  **注意：**
> > >
> > >  一旦try里面出现了问题，就会在这里把问题跑出去，然后和catch 里面的问题进行匹配，一旦有匹配的就执行catch里面的处理，然后结束了try...catch 。
> > >
> > > 继续执行后面的语句。
> > >
> > >​    **注意事项：**
> > >
> > >  * 能明确异常类名的尽量明确，实在明确不了的用大的（Exception），因为Exception是RuntimeException的父类，而异常类名是RuntimeException的子类，Exception是爷爷，可以用，但是用的时候，要从其子类，孙类中一个个查找，这样效率比较低。
> > >- 异常类名是平级关系的catch处理时，谁在前谁在后都无所谓，但是如果出现了父子关系，父必须在后面。
> > >
> > >**try...catch...finally的处理格式：**
> > >
> > >try{
> > >  可能出现问题的代码;
> > >}catch(异常名 变量){
> > >  针对问题的处理;
> > >}finally{
> > >  释放资源;
> > >}
> > >
> > >**变形格式**
> > >
> > >try{
> > >  可能出现问题的代码;
> > >}catch(异常名 变量){
> > >
> > >针对问题的处理
> > >
> > >}
> > >
> > >**JDk7出现了一个新的异常处理方案，处理多个异常：**
> > >
> > >> try{
> > >> }catch(异常类名 | 异常类名 | 异常类名|...变量){
> > >>   ...
> > >> }
> > >
> > > **注意：这个方法虽然简洁，但是不够好。**
> > >
> > >  * **处理方式是一样的（但是，实际开发中，好多时候可能就是针对同类型的问题，给出同一个处理）**
> > >  * **多个异常之间必须是平级关系，**
> >
> > **编译时异常和运行时异常的区别**
> >
> > **所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常**
> >
> > ​	编译时异常
> >
> > ​		java程序必须显示处理，否则程序聚会发生错误，无法通过编译
> >
> > ​	运行时异常
> >
> > ​		无需显示处理，也可以和编译时异常一样处理。 
> >
> > 
>
> **Throwable中的方法:**
>
> > **getMessage()**
> >
> > ​	获取异常信息，返回字符串
> >
> > **toString()**
> >
> > ​	获取异常类名和异常信息，返回字符串,结果是一下字符串的串联：
> >
> >   *  **次对象的类的name（全路径名）**
> >
> >   *  **“：”（冒号和一个空格）**
> >
> >   *  调用此对象getLocalizedMessage()方法的结果 （默认返回的是getMessage（）的内容）
> >
> >      **如果getLocalizedMessage返回null，则只返回类名称**
> >
> > **printStackTrace()**
> >
> > ​	获取异常类名和异常信息，以及异常出现在程序中的位置，返回值void
> >
> > **printStackTrace(PrintStream s)**
> >
> > ​	通过该方法将异常内容保存在日志文件中，以方便查阅
>
> ##**throws**
>
> 定义功能方法时，需要把出现的问题暴露出来让调用者去处理，那么通过Throwas在方法上标识。
>
> 有些时候，我们是可以对异常进行处理的，但是又有些时候，我们对异常是处理不了的
>
> 或者说，我处理不了，就不处理 了
>
> 为了解决出错问题，java针对这种情况，就提供了另一种处理方案：抛出
>
> 格式：
>
> ​	theows 异常类名
>
> ​	注意：
>
> ​		这种格式必须跟在方法的括号后面
>
> 注意：尽量不要在main方法上抛出异常
>
> 小结：
>
> ​	编译时期异常的抛出，将来调用者必须处理
>
> ​	运行时期异常的抛出，将来调用者可以不用处理
>
> ## throw
>
> ##在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。
>
> ## throws 和throw 的区别
>
> ## throws
>
> * 用在方法声明的后面，跟的是异常类名
>
> * 可以跟多个异常类名，用逗号隔开
>
> * 表示抛出异常，由该方法的调用者来处理
>
> * throws 表示出现异常的一种可能性，并不一定会发生这些异常。
>
>   ## throw
>
>   * 用在方法体内，跟的是异常对象名
>   * 只能抛出一个异常对象名
>   * 表示抛出异常，由方法体内的语句处理
>   * throw 则是抛出了异常，执行throw则一定抛出了某种异常
>
>   ## 如何处理异常
>
>   原则：如果该功能内部可以将问题处理，就用try，如果处理不了，交由调用者处理，就用throw
>
>   区别：
>
>   ​	后续程序需要继续运行就用try
>
>   ​	后续程序不需要继续运行就用throws
>
>   举例，
>
>   ​	感冒了自己吃点药就好了，try
>
>   ​	吃了好几天哟啊都咩有结果得了H7N9，那就得throw到医院
>
>   ​	如果医院没有特效药，就变成了error
>
>   ## finally的特点
>
>   * 被finally控制的语句体一定会执行，但是。如果在执行finally之前JVM退出了，就不能执行了。
>   * 特殊情况，在执行到点李莲英之前JVM退出了（比如System.exit（0））
>
>   ## finally 的作用
>
>   用于释放资源，在IO流操作和数据库操作中会见到
>
>   ## finally相关的面试题
>
>   ###final   finally 和finalize 的区别
>
>   * final   finally  finalize
>   * final: 最终的意思，可以修饰类，成员变量，成员方法
>     * 		修饰类     类不能被继承
>       * 	修饰变量   变量是常量
>         * 修饰方法  方法不能别重写
>   * finally  是异常处理的一部分，用于释放资源
>     * 		一般来说，代码肯定会执行，特殊情况：在执行到finally之前JVM就退出了
>   * finalize  是Object 的一个方法，用于垃圾回收（这个开发中很少见）
>
>   ###如果catch里面有return语句，请问finally的代码还会执行么？如果会，请问是在return前还是return后、
>
>   会，前。准确的说应该在中间
>
>   ```java 
>   public class FinallyDemo2 {
>   	public static void main(String[] args) {
>   		System.out.println(getInt());
>   	}
>   	public static int getInt(){
>   		int a = 10;
>   		try{
>   			System.out.println(10/0);//抛异常，走catch
>   			a=20;
>   		}catch(ArithmeticException ae){
>   			a=30;//a = 30 ,因为有finally ，所以程序跳过return后又走了，finally
>   			return a;
>   			//return a 在程序执行到这一步的时候，不是return a   而是 return 30 .，这趟返回路径就形成了
>   			//但是，它发现后面还有finally ，所以继续执行finally 的内容，a = 40 
>   		//再次回到返回路径，return   30 
>   		}finally{
>   			a = 40 ;//a= 40，走完finally，没有继续往下走，又返回catch里面，走return
>             
>   		}
>   		return a ;
>         
>   		
>   	}
>
>   }
>   ```
>
>   ​
>
>   ### try...catch...finally的格式变形
>
>   * try ... catch ...finally
>   * try ...catch
>   * try ...catch ...catch..
>   * try... catch...catch...finally
>   * try...finally           [这样做的的目的是为了 释放资源]
>
>   ## 自定义异常
>
>   考试成绩必须在0~100之间
>
>   自定义异常
>
>   ​	继承自Exception
>
>   ​			编译都要检查
>
>   ​	继承自RuntimeException
>
>   ​			编译不需要检查
>
>   ## 异常注意事项
>
>   * 子类重写父类方法时，子类的方法必须抛出相同的异常，或父类异常的子类（父亲坏了，儿子不能比父亲更坏）
>   * 如果父类抛出了多个异常，子类重写父类时，只能抛出相同的异常或者是它的子集，子类不能抛出父类没有的异常
>   * 如果被重写的方法没有抛出异常，那么子类的方法绝对不可以抛出异常，如果子类方法内有异常发生，那么子类只能try，不能throws
>
>   ​
>
>   ​
>
> 
>
> ​	
>
> ​	   
>
> 
>
> ### **2.file**
>
> ### **3.递归**
>
> ### **4.字节流**
>
> ### **5.转换流**
>
> ### **6.字符流**
>
> ### **7.其他流**
>
> 
>
> 

